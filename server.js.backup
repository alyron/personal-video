const express = require('express');
const fs = require('fs');
const path = require('path');
const http = require('http');
const https = require('https');
const cookieParser = require('cookie-parser');
const crypto = require('crypto');

// Load configuration
const config = require('./config.json');

// Create Express app
const app = express();
app.use(cookieParser());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Create users map for quick lookup
const users = {};
config.users.forEach(user => {
  users[user.username] = user.password;
});

// Session storage (in-memory, simple implementation)
const sessions = new Map();

// Video ID storage (hash ID -> { dirName, relativePath, createdAt })
const videoIdMap = new Map();

// Video cache (stores scanned videos)
const videoCache = {
  videos: [],
  isScanning: false,
  lastScanTime: 0,
  scanProgress: {
    total: 0,
    current: 0
  }
};

// Supported video extensions
const VIDEO_EXTENSIONS = ['.mp4', '.mkv', '.avi', '.mov', '.webm'];

// Recursively scan directory for video files
function scanDirectoryRecursively(dirPath, dirName, dirConfigPath) {
  const videos = [];
  const visitedDirs = new Set(); // Prevent infinite loops

  function scan(currentPath, relativePath = '') {
    try {
      // Resolve real path to handle symlinks
      const realPath = fs.realpathSync(currentPath);

      // Check for circular references
      if (visitedDirs.has(realPath)) {
        console.warn(`è­¦å‘Š: æ£€æµ‹åˆ°å¾ªç¯å¼•ç”¨ï¼Œè·³è¿‡ - ${currentPath}`);
        return;
      }

      visitedDirs.add(realPath);

      const items = fs.readdirSync(currentPath);

      items.forEach(item => {
        const itemPath = path.join(currentPath, item);
        const relativeItemPath = relativePath ? path.join(relativePath, item) : item;

        try {
          const stat = fs.statSync(itemPath);

          if (stat.isDirectory()) {
            // Recursively scan subdirectories
            scan(itemPath, relativeItemPath);
          } else {
            // Check if it's a video file
            const ext = path.extname(item).toLowerCase();
            if (VIDEO_EXTENSIONS.includes(ext)) {
              // Get relative path from root video directory
              const pathFromRoot = path.relative(path.resolve(dirConfigPath), itemPath);

              videos.push({
                name: item,
                relativePath: relativeItemPath,
                fullPath: itemPath,
                dirName: dirName,
                dirPath: dirConfigPath,
                size: (stat.size / (1024 * 1024)).toFixed(2) + ' MB',
                modified: stat.mtime.toLocaleString('zh-CN')
              });
            }
          }
        } catch (statError) {
          console.warn(`è­¦å‘Š: æ— æ³•è¯»å–æ–‡ä»¶ ${itemPath}: ${statError.message}`);
        }
      });

      // Remove from visited set after processing
      visitedDirs.delete(realPath);

    } catch (err) {
      console.warn(`è­¦å‘Š: æ— æ³•è¯»å–ç›®å½• ${currentPath}: ${err.message}`);
    }
  }

  try {
    scan(dirPath);
  } catch (err) {
    console.error(`é”™è¯¯: æ‰«æç›®å½•å¤±è´¥ ${dirPath}: ${err.message}`);
  }

  return videos;
}

// Generate a hash ID for video
function generateVideoId(dirName, filename) {
  const data = `${dirName}:${filename}:${Date.now()}:${Math.random()}`;
  return crypto.createHash('sha256').update(data).digest('hex').substring(0, 16);
}

// Get or create video ID
function getVideoId(dirName, relativePath) {
  const key = `${dirName}:${relativePath}`;

  // Check if we already have an ID for this video
  for (const [id, info] of videoIdMap.entries()) {
    if (info.dirName === dirName && info.relativePath === relativePath) {
      // Update last accessed time
      info.lastAccessed = Date.now();
      return id;
    }
  }

  // Create new ID
  const videoId = generateVideoId(dirName, relativePath);
  videoIdMap.set(videoId, {
    dirName,
    relativePath,
    createdAt: Date.now(),
    lastAccessed: Date.now()
  });

  return videoId;
}

// Get video info by ID
function getVideoById(videoId) {
  const info = videoIdMap.get(videoId);
  if (info) {
    info.lastAccessed = Date.now();
    return info;
  }
  return null;
}

// Clean up old video IDs (older than 1 hour)
setInterval(() => {
  const now = Date.now();
  const oneHour = 60 * 60 * 1000;

  for (const [id, info] of videoIdMap.entries()) {
    if (now - info.lastAccessed > oneHour) {
      videoIdMap.delete(id);
    }
  }
}, 60 * 60 * 1000); // Run every hour

// Middleware to check authentication
function requireAuth(req, res, next) {
  const sessionId = req.cookies.sessionId;
  if (sessionId && sessions.has(sessionId)) {
    return next();
  }
  return res.redirect('/login');
}

// Login page
app.get('/login', (req, res) => {
  const error = req.query.error === '1' ? '<p style="color: red;">ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯</p>' : '';
  res.send(`
    <!DOCTYPE html>
    <html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ç¨‹åºæµ‹è¯• - ç™»å½•</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                margin: 0;
                background-color: #f5f5f5;
            }
            .login-container {
                background-color: white;
                padding: 40px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                width: 300px;
            }
            h1 {
                text-align: center;
                color: #333;
                margin-bottom: 30px;
            }
            .form-group {
                margin-bottom: 20px;
            }
            label {
                display: block;
                margin-bottom: 5px;
                color: #555;
            }
            input {
                width: 100%;
                padding: 10px;
                border: 1px solid #ddd;
                border-radius: 4px;
                box-sizing: border-box;
            }
            button {
                width: 100%;
                padding: 10px;
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 16px;
            }
            button:hover {
                background-color: #45a049;
            }
        </style>
    </head>
    <body>
        <div class="login-container">
            <h1>ç¨‹åºæµ‹è¯•</h1>
            <form action="/login" method="POST">
                <div class="form-group">
                    <label for="username">ç”¨æˆ·å:</label>
                    <input type="text" id="username" name="username" required>
                </div>
                <div class="form-group">
                    <label for="password">å¯†ç :</label>
                    <input type="password" id="password" name="password" required>
                </div>
                ${error}
                <button type="submit">ç™»å½•</button>
            </form>
        </div>
    </body>
    </html>
  `);
});

// Login handler
app.post('/login', (req, res) => {
  const { username, password } = req.body;
  if (users[username] && users[username] === password) {
    const sessionId = Date.now().toString() + Math.random().toString(36).substring(7);
    sessions.set(sessionId, { username, createdAt: Date.now() });
    res.cookie('sessionId', sessionId, { maxAge: 24 * 60 * 60 * 1000 }); // 24 hours
    return res.redirect('/');
  }
  return res.redirect('/login?error=1');
});

// Logout
app.get('/logout', (req, res) => {
  const sessionId = req.cookies.sessionId;
  if (sessionId) {
    sessions.delete(sessionId);
  }
  res.clearCookie('sessionId');
  res.redirect('/login');
});

// Video list page (main page)
app.get('/', requireAuth, (req, res) => {
  let allVideos = [];

  // Scan all configured directories recursively
  config.videoDirs.forEach(dirConfig => {
    const videoDir = path.resolve(dirConfig.path);

    if (!fs.existsSync(videoDir)) {
      console.warn(`è­¦å‘Š: ç›®å½•ä¸å­˜åœ¨ - ${videoDir}`);
      return;
    }

    if (!fs.statSync(videoDir).isDirectory()) {
      console.warn(`è­¦å‘Š: è·¯å¾„ä¸æ˜¯ç›®å½• - ${videoDir}`);
      return;
    }

    // Recursively scan directory for videos
    const videos = scanDirectoryRecursively(videoDir, dirConfig.name, dirConfig.path);
    allVideos.push(...videos);

    console.log(`æ‰«æç›®å½• ${dirConfig.name}: æ‰¾åˆ° ${videos.length} ä¸ªè§†é¢‘æ–‡ä»¶`);
  });

  console.log(`æ€»è®¡æ‰¾åˆ° ${allVideos.length} ä¸ªè§†é¢‘æ–‡ä»¶`);

  // Sort videos by name
  allVideos.sort((a, b) => a.name.localeCompare(b.name));

  // Get unique directory names for grouping
  const dirGroups = [...new Set(allVideos.map(v => v.dirName))];

  res.send(`
    <!DOCTYPE html>
    <html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>è§†é¢‘åˆ—è¡¨</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 0;
                padding: 20px;
                background-color: #f5f5f5;
            }
            .header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                background-color: white;
                padding: 20px;
                border-radius: 8px;
                margin-bottom: 20px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .header h1 {
                margin: 0;
                color: #333;
            }
            .logout-btn {
                padding: 10px 20px;
                background-color: #f44336;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                text-decoration: none;
            }
            .logout-btn:hover {
                background-color: #da190b;
            }
            .video-list {
                background-color: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .dir-group {
                margin-bottom: 30px;
            }
            .dir-header {
                background-color: #4CAF50;
                color: white;
                padding: 10px 15px;
                border-radius: 5px;
                margin-bottom: 15px;
                font-size: 16px;
                font-weight: bold;
            }
            .video-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 15px;
                border-bottom: 1px solid #eee;
                transition: background-color 0.3s;
            }
            .video-item:last-child {
                border-bottom: none;
            }
            .video-item:hover {
                background-color: #f9f9f9;
            }
            .video-info {
                flex: 1;
            }
            .video-path {
                font-size: 12px;
                color: #999;
                margin-bottom: 3px;
                font-family: 'Courier New', monospace;
            }
            .video-name {
                font-size: 18px;
                color: #333;
                margin-bottom: 5px;
            }
            .video-meta {
                font-size: 14px;
                color: #666;
            }
            .watch-btn {
                padding: 8px 20px;
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                text-decoration: none;
                display: inline-block;
            }
            .watch-btn:hover {
                background-color: #0b7dda;
            }
            .empty {
                text-align: center;
                padding: 40px;
                color: #666;
            }
            .stats {
                margin-top: 20px;
                padding: 15px;
                background-color: #e3f2fd;
                border-radius: 5px;
                color: #1976d2;
            }
        </style>
    </head>
    <body>
        <div class="header">
            <h1>ğŸ“º è§†é¢‘åˆ—è¡¨</h1>
            <a href="/logout" class="logout-btn">é€€å‡ºç™»å½•</a>
        </div>
        <div class="video-list">
            ${allVideos.length === 0 ?
                '<div class="empty">æ²¡æœ‰æ‰¾åˆ°è§†é¢‘æ–‡ä»¶</div>' :
                `
                <div class="stats">
                    å…±æ‰¾åˆ° ${allVideos.length} ä¸ªè§†é¢‘æ–‡ä»¶ï¼Œæ¥è‡ª ${dirGroups.length} ä¸ªç›®å½•
                </div>
                ` + dirGroups.map(dirName => {
                  const dirVideos = allVideos.filter(v => v.dirName === dirName);
                  return `
                    <div class="dir-group">
                        <div class="dir-header">ğŸ“ ${dirName} (${dirVideos.length} ä¸ªè§†é¢‘)</div>
                        ${dirVideos.map(video => {
                          const videoId = getVideoId(video.dirName, video.relativePath);
                          const displayPath = video.relativePath.replace(/\\/g, '/');
                          return `
                            <div class="video-item">
                                <div class="video-info">
                                    ${displayPath !== video.name ? `<div class="video-path">ğŸ“‚ ${displayPath}</div>` : ''}
                                    <div class="video-name">${video.name}</div>
                                    <div class="video-meta">å¤§å°: ${video.size} | ä¿®æ”¹æ—¶é—´: ${video.modified}</div>
                                </div>
                                <a href="/video/${videoId}" class="watch-btn">è§‚çœ‹</a>
                            </div>
                          `;
                        }).join('')}
                    </div>
                  `;
                }).join('')
            }
        </div>
    </body>
    </html>
  `);
});

// Serve static files from public directory
app.use(express.static(path.join(__dirname, 'public')));

// Video info endpoint (GET video metadata by ID)
app.post('/video-info', requireAuth, (req, res) => {
  const { videoId } = req.body;

  if (!videoId) {
    return res.status(400).json({ error: 'ç¼ºå°‘ videoId å‚æ•°' });
  }

  // Get video info by ID
  const videoInfo = getVideoById(videoId);
  if (!videoInfo) {
    return res.status(404).json({ error: 'è§†é¢‘ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ' });
  }

  // Get file extension for content type
  const ext = path.extname(videoInfo.filename).toLowerCase();
  const contentTypeMap = {
    '.mp4': 'video/mp4',
    '.mkv': 'video/x-matroska',
    '.avi': 'video/x-msvideo',
    '.mov': 'video/quicktime',
    '.webm': 'video/webm'
  };
  const contentType = contentTypeMap[ext] || 'video/mp4';

  // Return video info (including filename for display)
  res.json({
    dirName: videoInfo.dirName,
    relativePath: videoInfo.relativePath,
    filename: path.basename(videoInfo.relativePath),  // Get filename from relative path
    contentType: contentType
  });
});

// Video player page
app.get('/video/:videoId', requireAuth, (req, res) => {
  const videoId = req.params.videoId;

  // Get video info by ID
  const videoInfo = getVideoById(videoId);
  if (!videoInfo) {
    return res.status(404).send('è§†é¢‘ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ');
  }

  const dirName = videoInfo.dirName;

  // Serve the player HTML
  res.sendFile(path.join(__dirname, 'public', 'player.html'));
});

// Stream video file (POST request with videoId in body)
app.post('/stream', requireAuth, (req, res) => {
  const { videoId } = req.body;

  if (!videoId) {
    return res.status(400).json({ error: 'ç¼ºå°‘ videoId å‚æ•°' });
  }

  // Get video info by ID
  const videoInfo = getVideoById(videoId);
  if (!videoInfo) {
    return res.status(404).json({ error: 'è§†é¢‘ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ' });
  }

  const dirName = videoInfo.dirName;
  const relativePath = videoInfo.relativePath;

  // Find the directory config by name
  const dirConfig = config.videoDirs.find(dir => dir.name === dirName);
  if (!dirConfig) {
    return res.status(404).json({ error: 'ç›®å½•é…ç½®ä¸å­˜åœ¨' });
  }

  const videoDir = path.resolve(dirConfig.path);
  const filePath = path.join(videoDir, relativePath);

  if (!fs.existsSync(filePath)) {
    return res.status(404).json({ error: 'è§†é¢‘æ–‡ä»¶ä¸å­˜åœ¨' });
  }

  const stat = fs.statSync(filePath);
  const fileSize = stat.size;

  // Get filename from relative path for display
  const filename = path.basename(relativePath);

  // Determine content type based on file extension
  const ext = path.extname(filename).toLowerCase();
  const contentTypeMap = {
    '.mp4': 'video/mp4',
    '.mkv': 'video/x-matroska',
    '.avi': 'video/x-msvideo',
    '.mov': 'video/quicktime',
    '.webm': 'video/webm'
  };
  const contentType = contentTypeMap[ext] || 'video/mp4';

  // Set headers
  res.setHeader('Content-Type', contentType);
  res.setHeader('Content-Length', fileSize);
  res.setHeader('Accept-Ranges', 'bytes');

  // Stream the file
  const fileStream = fs.createReadStream(filePath);
  fileStream.pipe(res);

  fileStream.on('error', (err) => {
    console.error('Error streaming video:', err);
    if (!res.headersSent) {
      res.status(500).json({ error: 'è§†é¢‘æµä¼ è¾“å¤±è´¥' });
    }
  });
});

// Create server (HTTP or HTTPS based on configuration)
const port = config.port || 18899;
const host = config.host || '::'; // '::' binds to all IPv6 and IPv4 addresses

let server;

if (config.https && config.https.enabled) {
  // HTTPS server
  try {
    const httpsOptions = {
      key: fs.readFileSync(config.https.key),
      cert: fs.readFileSync(config.https.cert)
    };
    server = https.createServer(httpsOptions, app);
  } catch (err) {
    console.error('é”™è¯¯: æ— æ³•è¯»å–SSLè¯ä¹¦æ–‡ä»¶');
    console.error('è¯·ç¡®ä¿ä»¥ä¸‹æ–‡ä»¶å­˜åœ¨:');
    console.error(`  - ${config.https.key}`);
    console.error(`  - ${config.https.cert}`);
    console.error('');
    console.error('å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ç”Ÿæˆè‡ªç­¾åè¯ä¹¦:');
    console.error('  openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes');
    process.exit(1);
  }
} else {
  // HTTP server
  server = http.createServer(app);
}

// Start server
server.listen(port, host, () => {
  const protocol = config.https && config.https.enabled ? 'https' : 'http';
  console.log('=================================================');
  console.log('è§†é¢‘æœåŠ¡å·²å¯åŠ¨ï¼');
  console.log('=================================================');
  console.log(`åè®®: ${protocol.toUpperCase()}`);
  console.log(`è®¿é—®åœ°å€ (IPv6): ${protocol}://[::1]:${port}`);
  console.log(`è®¿é—®åœ°å€ (IPv4): ${protocol}://127.0.0.1:${port}`);
  console.log(`è®¿é—®åœ°å€ (æœ¬åœ°ç½‘ç»œ IPv4): ${protocol}://<æœ¬æœºIP>:${port}`);
  console.log(`è®¿é—®åœ°å€ (æœ¬åœ°ç½‘ç»œ IPv6): ${protocol}://[æœ¬æœºIPv6åœ°å€]:${port}`);
  console.log('=================================================');
  console.log('é»˜è®¤ç™»å½•ä¿¡æ¯:');
  console.log('ç”¨æˆ·å: admin');
  console.log('å¯†ç : password123');
  console.log('=================================================');
  console.log('æç¤º: å¯ä»¥ä¿®æ”¹ config.json æ–‡ä»¶æ¥æ›´æ”¹ç”¨æˆ·åã€å¯†ç å’Œå…¶ä»–è®¾ç½®');
  if (config.https && config.https.enabled) {
    console.log('HTTPSå·²å¯ç”¨ï¼Œä½¿ç”¨åŠ å¯†è¿æ¥ä¼ è¾“æ•°æ®');
  }
  console.log('=================================================');
});

// Handle server errors
server.on('error', (err) => {
  if (err.code === 'EADDRINUSE') {
    console.error(`é”™è¯¯: ç«¯å£ ${port} å·²è¢«å ç”¨ï¼Œè¯·æ›´æ¢ç«¯å£æˆ–å…³é—­å ç”¨è¯¥ç«¯å£çš„ç¨‹åº`);
  } else {
    console.error('æœåŠ¡å™¨é”™è¯¯:', err);
  }
});
