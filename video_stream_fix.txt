// GET video stream endpoint with Range support
app.get('/video-stream/:videoId', requireAuth, (req, res) => {
  const videoId = req.params.videoId;

  if (!videoId) {
    return res.status(400).json({ error: '缺少 videoId 参数' });
  }

  // Get video info by ID
  const videoInfo = getVideoById(videoId);
  if (!videoInfo) {
    return res.status(404).json({ error: '视频不存在或已过期' });
  }

  const dirName = videoInfo.dirName;
  const relativePath = videoInfo.relativePath;

  // Find directory config by name
  const dirConfig = config.videoDirs.find(dir => dir.name === dirName);
  if (!dirConfig) {
    return res.status(404).json({ error: '目录配置不存在' });
  }

  const videoDir = path.resolve(dirConfig.path);
  const filePath = path.join(videoDir, relativePath);

  if (!fs.existsSync(filePath)) {
    return res.status(404).json({ error: '视频文件不存在' });
  }

  const stat = fs.statSync(filePath);
  const fileSize = stat.size;

  // Get filename from relative path for display
  const filename = path.basename(relativePath);

  // Determine content type based on file extension
  const ext = path.extname(filename).toLowerCase();
  const contentTypeMap = {
    '.mp4': 'video/mp4',
    '.mkv': 'video/x-matroska',
    '.avi': 'video/x-msvideo',
    '.mov': 'video/quicktime',
    '.webm': 'video/webm'
  };
  const contentType = contentTypeMap[ext] || 'video/mp4';

  // Check for Range header (for seeking/skipping)
  const range = req.headers.range;

  if (range) {
    // Parse Range header: "bytes=start-end"
    const parts = range.replace(/bytes=/, "").split("-");
    const start = parseInt(parts[0], 10);
    const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
    const chunksize = (end - start) + 1;

    // Validate range
    if (isNaN(start) || isNaN(end) || start >= fileSize || end >= fileSize || start > end) {
      return res.status(416).json({ error: '请求范围无效' });
    }

    console.log(`Stream range: ${start}-${end} (${chunksize} bytes)`);

    // Create read stream for requested range
    const fileStream = fs.createReadStream(filePath, { start, end });

    // Set headers for partial content
    res.writeHead(206, {
      'Content-Range': `bytes ${start}-${end}/${fileSize}`,
      'Accept-Ranges': 'bytes',
      'Content-Length': chunksize,
      'Content-Type': contentType,
      'Cache-Control': 'public, max-age=3600',
      'X-Content-Duration': Math.floor(fileSize / 1000000) // Approximate duration
    });

    fileStream.pipe(res);

    fileStream.on('error', (err) => {
      console.error('Error streaming video:', err);
      if (!res.headersSent) {
        res.status(500).json({ error: '视频流传输失败' });
      }
    });
  } else {
    // No Range header, stream entire file
    console.log(`Stream full file: ${filePath} (${fileSize} bytes)`);

    const fileStream = fs.createReadStream(filePath);

    // Set headers for full content
    res.writeHead(200, {
      'Content-Length': fileSize,
      'Content-Type': contentType,
      'Accept-Ranges': 'bytes',
      'Cache-Control': 'public, max-age=3600',
      'X-Content-Duration': Math.floor(fileSize / 1000000) // Approximate duration
    });

    fileStream.pipe(res);

    fileStream.on('error', (err) => {
      console.error('Error streaming video:', err);
      if (!res.headersSent) {
        res.status(500).json({ error: '视频流传输失败' });
      }
    });
  }
});


